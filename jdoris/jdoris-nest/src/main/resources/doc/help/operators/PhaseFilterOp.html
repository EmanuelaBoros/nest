<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><title>Help - Phase filter</title>

    <link rel="stylesheet" href="../style.css">
</head>

<body>
<table class="header">
    <tbody>
    <tr class="header">
        <td class="header">&nbsp; Phase Filtering of stacks of interferograms (InSAR operator)</td>
        <td class="header" align="right"><a href="../general/Overview.html"><img src="../images/HeaderLogo.jpg"
                                                                                 border="0"></a></td>
    </tr>
    </tbody>
</table>
<h3>Phase filtering of stacks of interferogram</h3>

<p>
    This operator can be used to optionally filter the stacks complex interferograms. The filtering is performed
    in order to reduce noise, e.g., for visualization or to aid the phase unwrapping. It is probably best run
    after step Interferogram subtraction, though this depends on the application.
</p>

<p>
    The following filtering methods are implemented: Goldstein method ("goldstein"), Spatial Convolution
    ("spatialconv"). Functionality to load user defined filters will be soon implemented.
</p>

<p>
    The basic principles of implemented complex phase filters is as follows:
    In case of the Goldstein filtering, the interferometeric fringes become
    sharper because with filtering the peak in the spectrum (caused by the fringes) is given
    a higher relative weight.
    Method "spatial convolution" is a simple spatial convolution with a certain function acting as a
    kernel, e.g., a 3 point moving average.
    Method spectral (coming soon) is a multiplication of the spectrum with the kernel specified in an operator
    input (e.g. a spectral low pass filter (LPF)).
    Fpr more details refer to the implementation section and listed references.

<h4>Operator parameters:</h4>&nbsp;&nbsp;
The following parameters are used by this operator:
<ol>
    <li>
        FILTERING METHOD: Select filtering method. Chose among goldstein method ("goldstein"),
        spatial convolution ("convolution"), or spectral filter ("spectral").
        Note that different methods have different parameters and level of fine tuning.
    </li>
    <li>
        ALPHA (Goldstein method only): The Alpha parameter, is the input parameter only for method goldstein.
        This parameter, can be understood as a "smoothness coefficient" of the filter, and it defines the level of
        filtering. The value for the alpha, must be in range from [0, 1]. The value 0 means no filtering, and 1 most
        filtering. The Alpha parameter is connected and indirectly influenced with the input parameters for the
        Filtering Kernel - a higher smoothing, gives a relative decrease to the peak, and thus the
        effect of the alpha.
    </li>
    <li>
        BLOCKSIZE: This parameter is for methods "goldstein" and "spectral" only. It defines the size of the blocks
        that are filtered. The parameter must be a power of 2 value. It should be large enough so that the spectrum
        can be estimated, and small enough that it contains a peak frequency (1 trend in phase).
        Recommended value for block-size is: 32 pixels.
    </li>
    <li>
        OVERLAP: Input for method "goldstein" and "spectral" only. Half of the size of the overlap between
        consecutive filtering blocks and tiles, so that partially the same data is used for filtering. The
        total overlap should be smaller than BLOCKSIZE. If this parameter is set to BLOCKSIZE/2-1
        (the maximum value for this parameter) then each output pixel is filtered based on the spectrum that
        is centered around it - this is probably the most optimal way of filtering, but may well be the most time
        consuming
        one.
    </li>
    <li>
        FILTERING KERNEL: This input parameter is for methods "goldstein" and "spatialconv" only. It defines the
        one-dimension kernel function used to perform convolution.
        A number of the pre-defined kernels is offered, while future releases will have functionality that can allow
        users to define their own 1D filtering kernels.
        For method GOLDSTEIN: default to kernel is [1 2 3 2 1]. This kernel is used to smooth the amplitude
        of the spectrum of the complex interferogram. The spectrum is later scaled by the smoothed spectrum to the
        power alpha.
        For method SPATIALCONV: Default is a 3 point moving average [1 1 1] convolution. The real and imaginary part
        is averaged separately this way. For more info see implementation section.
    </li>

</ol>

<h4>Source bands:</h4>&nbsp;&nbsp;
<p> Source Bands are stack of interferograms.</p>

<h4>Output bands:</h4>&nbsp;&nbsp;
<p> Output Bands are stack of phase filtered interferograms.

<h4>Implementation (TODO: clarify and update):</h4>&nbsp;&nbsp;

<ol>
    <li>
        SPECTRAL METHOD: This method is implemented in the similar way as the goldstein method - operating on small
        data blocks with overlap. Algorithm reads data block-per-block, and on every block it performs
        a 2D FFT operation, and then it multiplies spectra of the data block point-wise with the kernel.
        The kernel is padded with zeros and centered around zero frequency.
    </li>
    <li>
        SPATIAL CONVOLUTION METHOD: The input complex interferogram is convoluted with a 2D kernel by FFT's.
        The 2D kernel is computed from 1D kernel, defined as an input parameter of the operator.

        TODO: EXAMPLE

        The block-size for the convolution is chosen as high as possible.

        In future releases, it will be also possible to load 2D kernel from external file. Note that only odd sized
        kernels can be used, so if you want to use the kernel of odd simply add a zero to make a kernel size even.
    </li>
    <li>
        GOLDSTEIN METHOD: The algorithm is implemented as:
        * Read in a data tile (T).
        * Get block (B) from input tile as input block.
        * B = fft2d(B) (obtain complex spectrum)
        * A = abs(B) (compute magnitude of spectrum)
        * S = smooth(A) (perform convolution with kernel)
        * S = S/max(S) (S between 0 and 1)
        * B = B.S^alpha (weight complex spectrum)
        * B = ifft2d(B) (result in space domain)
        * If all blocks of tile done, write to disk.
    </li>
</ol>
<br>
<br>
<hr>
</body>
</html>