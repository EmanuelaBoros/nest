/*
 * Copyright (C) 2009 by Array Systems Computing Inc
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation. This program is distributed in the hope it will
 * be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.esa.nest.gpf;

import com.bc.ceres.core.ProgressMonitor;
import org.esa.beam.dataio.envisat.EnvisatAuxReader;
import org.esa.beam.framework.datamodel.*;
import org.esa.beam.framework.gpf.OperatorException;
import org.esa.beam.framework.gpf.Tile;
import org.esa.beam.framework.gpf.internal.OperatorContext;
import org.esa.beam.util.math.MathUtils;
import org.esa.nest.datamodel.AbstractMetadata;
import org.esa.nest.datamodel.Calibrator;
import org.esa.nest.datamodel.Unit;
import org.esa.nest.util.Settings;

import javax.media.jai.BorderExtender;
import javax.media.jai.JAI;
import javax.media.jai.PlanarImage;
import javax.media.jai.RasterFactory;
import javax.media.jai.operator.SubsampleAverageDescriptor;
import java.awt.*;
import java.awt.image.*;
import java.awt.image.renderable.ParameterBlock;
import java.io.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * The objective of SAR calibration is to provide imagery in which the pixel values can be directly related
 * to the radar backscatter of the scene. Though uncalibrated SAR imagery is sufficient for qualitative use,
 * calibrated SAR images are essential to quantitative use of SAR data. Typically processing of SAR data to
 * produce level 1 images does not include geometric and radiometric corrections and significant radiometric
 * and geometric bias remains. Corrections to the radiometric and geometric bias will therefore be applied
 * to SAR images so that the pixel values of SAR images are a true representation of the reflecting surface’s
 * radar backscatter. Calibration is necessary to compare SAR images acquired with different sensors as well
 * as when acquired from the same sensor but at different times, in different modes, or processed by different
 * processors.
 *
 * This operator applies the following calibrations to ERS-1 and ERS-2 SAR data products generated by different
 * processors at ESA/ESRIN and at different Processing and Archiving Facilities such as the German PAF(D-PAF),
 * the Italian PAF (I-PAF) and the United-Kingdom PAF (UK-PAF):
 *
 * 1. calibration constant correction
 * 2. antenna elevation pattern correction
 * 3. replica pulse power variations correction
 * 4. analogue to digital converter non-linearity correction
 */
public final class ERSCalibrator implements Calibrator {

    private Product sourceProduct;
    private Product targetProduct;

    private boolean outputImageScaleInDb = false;

    private Band sourceBand1;
    private Band sourceBand2;

    private MetadataElement abstractedMetadata = null;
    private String pafID; // processing facility identifier
    private String psID;  // processing system identifier
    private String pvID;  // processing version identifier
    private String missionType;
    private String sampleType;
    private String productType;
    private String extXCAFileName;

    private int sourceImageWidth;
    private int sourceImageHeight;
    private int windowWidth;
    private int windowHeight;
    private int blockWidth;
    private int blockHeight;

    private boolean applyAntennaPatternCorrection;
    private boolean applyRangeSpreadingLossCorrection;
    private boolean applyReplicaPowerCorrection;
    private boolean applyADCSaturationCorrection;

    private boolean isERS1Mission = false;
    private boolean isDetectedSampleType = false;
    private boolean isCEOSFormat = false;
    private boolean adcTestFlag = false;
    private boolean antennaPatternCorrectionFlag;
    private boolean rangeSpreadingLossCompFlag;
    private boolean adcSourceTileTopExtFlag;
    private boolean adcSourceTileBottomExtFlag;
    private boolean useExtXCAFile = false;

    private double rangeSpacing; // m
    private double azimuthSpacing; // m
    private double calibrationConstant;
    private double sceneCentreLatitude; // in degree
    private double replicaPulseVariationsCorrectionFactor;
    private double elevationAngle; // elevation angle for given swath IS2 VV, in degree

    private Date processingTime;
    private Date acquisitionTime;
    private Date time19910801; // =  681004800.0;  01-Aug-1991 00:00:00.000, in s
    private Date time19920401; // =  702086400.0;  01-Apr-1992 00:00:00.000, in s
    private Date time19920414; // =  703209600.0;  14-Apr-1992 00:00:00.000, in s
    private Date time19920901; // =  715305600.0;  01-Sep-1992 00:00:00.000, in s
    private Date time19930408; // =  734227200.0;  08-Apr-1993 00:00:00.000, in s
    private Date time19930628; // =  741225600.0;  28-Jun-1993 00:00:00.000, in s
    private Date time19941207; // =  786758400.0;  07-Dec-1994 00:00:00.000, in s
    private Date time19950317; // =  795398400.0;  17-Mar-1995 00:00:00.000, in s
    private Date time19950713; // =  805593600.0;  13-Jul-1995 00:00:00.000, in s
    private Date time19950716; // =  805852800.0;  16-Jul-1995 00:00:00.000, in s
    private Date time19951016; // =  813801600.0;  16-Oct-1995 00:00:00.000, in s
    private Date time19970120; // =  853718400.0;  20-Jan-1997 00:00:00.000, in s
    private Date time19980224; // =  888278400.0;  24-Feb-1998 00:00:00.000, in s
    private Date time20040904; // = 1094292254.0;  04-Sep-2004 10:04:14.000, in s
    private Date time20041014; // = 1097764631.0;  14-Oct-2004 14:37:11.000, in s

    private double[] incidenceAngles = null; // for a complete range line, in radian
    private double[] lookAngles = null; // for a complete range line, in radian
    private double[] rangeSpreadingLoss = null; // for a complete range line
    private double[] antennaPatternCorrFactor = null; // for a range line in current tile, in linear scale
    private double[] antennaPatternGain = null; // used in ADC, for a range line in current tile, in linear scale
    private double[][] appendixF1 = null; // ERS-1 SAR ADC Power Loss Correction Look-up Table, in dB
    private double[][] adcPowerLoss = null;
    private double[][] appendixF2 = null; // ERS-2 SAR ADC Power Loss Correction Look-up Table, in dB
    private double[][] appendixG1 = null; // initial ERS-1 SAR antenna pattern gain, in dB
    private double[][] appendixG2 = null; // improved ERS-1 SAR antenna pattern gain, in dB
    private double[][] appendixG3 = null; // ERS-2 SAR antenna pattern gain, in dB
    private double[][] appendixH = null;  // UK-PAF elevation antenna pattern correction, in dB
    private float[] antPatForPGS = null; // antenna pattern for swath IS2 VV for PGS product, in dB

    // parameters used for PGS-ENVISAT calibration
    private int numMPPRecords;

    private static final double referenceIncidenceAngle = 23.0 * MathUtils.DTOR; //  radian
    private static final double relativeLookAngle = 20.355; //  degree
    private static final double aGEM6 = 6378144; // GEM6: equatorial Earth radius in m (for VMP CEOS)
    private static final double bGEM6 = 6356759; // GEM6: polar Earth radius in m (for VMP CEOS)
    private static final double aWGS84 = 6378137; // WGS 84: equatorial Earth radius in m (for PGS CEOS)
    private static final double bWGS84 = 6356752.314245 ; // WGS 84: polar Earth radius in m (for PGS CEOS)
    private static final double referenceSlantRange = 847000; //  m
    private static final double lightSpeed = 299792458; //  m / s
    private static final double halfLightSpeed = lightSpeed / 2;
    private static final double underFlowFloat = 1.0e-30;
    private static final double windowDimInRange = 15000.0; //  m
    private static final double windowDimInAzimuth = 5000.0; //  m
    private static final double downSampleBlockSize = 100.0; // m
    private static final double ers1ApplyADCThreshold = -7.0; // dB
    private static final double ers2ApplyADCThreshold = -2.0; // dB

    private static final String D_PAF = "D-PAF";
    private static final String I_PAF = "I-PAF";
    private static final String UK_PAF = "UK-PAF";
    private static final String ESRIN = "ES";
    private static final String VMP = "VMP";

    /**
     * Default constructor. The graph processing framework
     * requires that an operator has a default constructor.
     */
    public ERSCalibrator() {
    }

    /**
     * Set flag indicating if target image is output in dB scale.
     */
    @Override
    public void setOutputImageIndB(boolean flag) {
        outputImageScaleInDb = flag;
    }

    /**
     * Set external auxiliary file.
     */
    @Override
    public void setExternalAuxFile(File file) throws OperatorException {
        if (file != null) {
            throw new OperatorException("No external auxiliary file should be selected for ERS product");
        }
    }
    
    /**

     */
    public void initialize(Product srcProduct, Product tgtProduct) throws OperatorException {

        try {
        sourceProduct = srcProduct;
        targetProduct = tgtProduct;

        sourceImageWidth = sourceProduct.getSceneRasterWidth();
        sourceImageHeight = sourceProduct.getSceneRasterHeight();
        //System.out.println("sourceImageWidth = " + sourceImageWidth + ", sourceImageHeight = " + sourceImageHeight);

        getImportantTimes();
        abstractedMetadata = AbstractMetadata.getAbstractedMetadata(sourceProduct);
        getMissionType(); // abs
        getSampleType();  // abs
        getProductType(); // abs
        getCalibrationFlags(); // abs
        getPixelSpacings(); // abs
        getProcessingTime(); // abs
        getProcessingSystemID();   // abs
        getProductAcquisitionTime(); // abs

        if (isCEOSFormat) { // CEOS

            getProcessingFacilityIDFromCEOS(); // ERS
            getProcessingVersionID();  // ERS
            getSceneCentreLatitude(); // ERS
            getCalibrationConstantFromCEOS(); // ERS

        } else { // ENVISAT

            getProcessingFacilityIDFromENVISAT(); // MPH
            getNumOfRecordsInMainProcParam(); // DSR.3
            getCalibrationConstantFromENVISAT(); // MPP
        }

        setCorrectionFlags();

        if (applyADCSaturationCorrection) {
            prepareForADCCorrection();
        }

        if (applyAntennaPatternCorrection || applyADCSaturationCorrection) {
            getAntennaPatternFromFile();
        }

        if (applyReplicaPowerCorrection || applyADCSaturationCorrection) {
            computeReplicaPulseVariationsCorrectionFactor();
        }

        if (isCEOSFormat) { // CEOS
            computeIncidenceAnglesLookAnglesRangeSpreadingLossForCEOS();
        } else { // ENVISAT
            computeIncidenceAnglesLookAnglesRangeSpreadingLossForENVISAT();
        }

        //computeIncidenceAnglesLookAnglesRangeSpreadingLoss();  // common to CEOS and ENVISAT

        updateTargetProductMetadata();

        } catch(Exception e) {
            throw new OperatorException(e);
        }
    }

    /**
     * Called by the framework in order to compute a tile for the given target band.
     * <p>The default implementation throws a runtime exception with the message "not implemented".</p>
     *
     * @param targetBand The target band.
     * @param targetTile The current tile associated with the target band to be computed.
     * @param pm         A progress monitor which should be used to determine computation cancelation requests.
     * @throws org.esa.beam.framework.gpf.OperatorException
     *          If an error occurs during computation of the target raster.
     */
    @Override
    public void computeTile(Band targetBand, Tile targetTile,
                            HashMap<String, String[]> targetBandNameToSourceBandName,
                            ProgressMonitor pm) throws OperatorException {

    try {
        final Rectangle targetTileRectangle = targetTile.getRectangle();

        final int x0 = targetTileRectangle.x;
        final int y0 = targetTileRectangle.y;
        final int w = targetTileRectangle.width;
        final int h = targetTileRectangle.height;

        //System.out.println("x0 = " + x0 + ", y0 = " + y0 + ", w = " + w + ", h = " + h);

        final ProductData trgData = targetTile.getDataBuffer();
        Tile sourceRaster1 = null;
        Tile sourceRaster2 = null;
        ProductData srcData1 = null;
        ProductData srcData2 = null;

        final String[] srcBandNames = targetBandNameToSourceBandName.get(targetBand.getName());
        if (srcBandNames.length == 1) {
            sourceBand1 = sourceProduct.getBand(srcBandNames[0]);
            sourceRaster1 = getSourceTile(sourceBand1, targetTileRectangle, pm);
            srcData1 = sourceRaster1.getDataBuffer();
        } else {
            sourceBand1 = sourceProduct.getBand(srcBandNames[0]);
            sourceBand2 = sourceProduct.getBand(srcBandNames[1]);
            sourceRaster1 = getSourceTile(sourceBand1, targetTileRectangle, pm);
            sourceRaster2 = getSourceTile(sourceBand2, targetTileRectangle, pm);
            srcData1 = sourceRaster1.getDataBuffer();
            srcData2 = sourceRaster2.getDataBuffer();
        }

        final Unit.UnitType bandUnit = Unit.getUnitType(sourceBand1);

        // copy band if unit is phase
        if(bandUnit == Unit.UnitType.PHASE) {
            targetTile.setRawSamples(sourceRaster1.getRawSamples());
            return;
        }

        if (applyAntennaPatternCorrection) {
            computeAntennaPatternCorrectionFactors(x0, w);
        }

        if (applyADCSaturationCorrection && !adcTestFlag) {
            if (!isADCNeeded(srcBandNames, bandUnit, pm)) {
                applyADCSaturationCorrection = false;
            }
            adcTestFlag = true;
        }

        if (applyADCSaturationCorrection && (h < blockHeight || w < blockWidth)) {
            applyADCSaturationCorrection = false;
        }

        if (applyADCSaturationCorrection) {
            if (antennaPatternCorrectionFlag) {
                computeAntennaPatternGain(x0, w);
            }
            computeADCPowerLossValuesForCurrentTile(x0, y0, w, h, pm, srcBandNames, bandUnit);
        }

        final double k = calibrationConstant * Math.sin(referenceIncidenceAngle);

        double sigma, dn, i, q;
        int index;
        int adcJ=0;
        for (int x = x0; x < x0 + w; x++) {
            OperatorContext.checkForCancelation(pm);

            final double sinIncidenceAngleByK = Math.sin(incidenceAngles[x]) / k;
            if (applyADCSaturationCorrection)
                adcJ = Math.min(((x - x0) / blockWidth), adcPowerLoss[0].length - 1);

            for (int y = y0; y < y0 + h; y++) {

                index = sourceRaster1.getDataBufferIndex(x, y);

                if (bandUnit == Unit.UnitType.AMPLITUDE) {
                    dn = srcData1.getElemDoubleAt(index);
                    sigma = dn*dn;
                } else if (bandUnit == Unit.UnitType.INTENSITY) {
                    sigma = srcData1.getElemDoubleAt(index);
                } else { // COMPLEX
                    i = srcData1.getElemDoubleAt(index);
                    q = srcData2.getElemDoubleAt(index);
                    sigma = i * i + q * q;
                }

                sigma *= sinIncidenceAngleByK;

                if (applyAntennaPatternCorrection) {
                    sigma *= antennaPatternCorrFactor[x-x0];
                }

                if (applyReplicaPowerCorrection) {
                    sigma *= replicaPulseVariationsCorrectionFactor;
                }

                if (applyADCSaturationCorrection) {
                    final int adcI = Math.min(((y - y0) / blockHeight), adcPowerLoss.length - 1);
                    sigma *= adcPowerLoss[adcI][adcJ];
                }

                if (outputImageScaleInDb) { // convert calibration result to dB
                    if (sigma < underFlowFloat) {
                        sigma = -underFlowFloat;
                    } else {
                        sigma = 10.0 * Math.log10(sigma);
                    }
                }

                trgData.setElemDoubleAt(targetTile.getDataBufferIndex(x, y), sigma);
            }
        }
    } catch(Exception e) {
        System.out.println(e.toString());
    }
    }

    /**
     * Compute some important times (in second). The time zone of GMT is always assumed.
     */
    private void getImportantTimes() {

        final SimpleDateFormat dateformat = new SimpleDateFormat("dd-MMM-yyyy HH:mm:ss.SSS");

        try {
            time19910801 = dateformat.parse("01-Aug-1991 00:00:00.000");
            time19920401 = dateformat.parse("01-Apr-1992 00:00:00.000");
            time19920414 = dateformat.parse("14-Apr-1992 00:00:00.000");
            time19920901 = dateformat.parse("01-Sep-1992 00:00:00.000");
            time19930408 = dateformat.parse("08-Apr-1993 00:00:00.000");
            time19930628 = dateformat.parse("28-Jun-1993 00:00:00.000");
            time19941207 = dateformat.parse("07-Dec-1994 00:00:00.000");
            time19950317 = dateformat.parse("17-Mar-1995 00:00:00.000");
            time19950713 = dateformat.parse("13-Jul-1995 00:00:00.000");
            time19950716 = dateformat.parse("16-Jul-1995 00:00:00.000");
            time19951016 = dateformat.parse("16-Oct-1995 00:00:00.000");
            time19970120 = dateformat.parse("20-Jan-1997 00:00:00.000");
            time19980224 = dateformat.parse("24-Feb-1998 00:00:00.000");
            time20040904 = dateformat.parse("04-Sep-2004 10:04:14.000");
            time20041014 = dateformat.parse("14-Oct-2004 14:37:11.000");
        } catch (ParseException e) {
            throw new OperatorException(e);
        }

        /*
        System.out.format("time19910801 = %13.3f%n",  time19910801);
        System.out.format("time19920401 = %13.3f%n",  time19920401);
        System.out.format("time19920414 = %13.3f%n",  time19920414);
        System.out.format("time19920901 = %13.3f%n",  time19920901);
        System.out.format("time19930408 = %13.3f%n",  time19930408);
        System.out.format("time19930628 = %13.3f%n",  time19930628);
        System.out.format("time19941207 = %13.3f%n",  time19941207);
        System.out.format("time19950317 = %13.3f%n",  time19950317);
        System.out.format("time19950713 = %13.3f%n",  time19950713);
        System.out.format("time19950716 = %13.3f%n",  time19950716);
        System.out.format("time19951016 = %13.3f%n",  time19951016);
        System.out.format("time19970120 = %13.3f%n",  time19970120);
        System.out.format("time19980224 = %13.3f%n",  time19980224);
        System.out.format("time20040904 = %13.3f%n",  time20040904);
        System.out.format("time20041014 = %13.3f%n",  time20041014);
        */
    }

    /**
     * Convert UTC time (dd-MMM-yyyy HH:mm:ss.sss) to seconds. The GMT time zone is always assumed.
     *
     * @param utcTime The UTC time string.
     * @return The time in second.
     */
    private static double convertUTCTimes(String utcTime) {

        double timeInSecond = 0.0;
        SimpleDateFormat simpledateformat;

        if (utcTime.length() == 23) {
            simpledateformat = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss.SSS");
        } else if (utcTime.length() == 24) {
            simpledateformat = new SimpleDateFormat("dd-MMM-yyyy HH:mm:ss.SSS");
        } else {
            throw new OperatorException("Incorrect UTC time string");
        }

        simpledateformat.setTimeZone(TimeZone.getTimeZone("UTC"));

        try {
            timeInSecond = (double)simpledateformat.parse(utcTime).getTime() / 1000.0; // ms to s
        } catch (ParseException e) {
            throw new OperatorException(e);
        }

        return timeInSecond;
    }

    /**
     * Get the mission type.
     */
    private void getMissionType() {

        final MetadataAttribute missionTypeAttr = abstractedMetadata.getAttribute(AbstractMetadata.MISSION);
        if (missionTypeAttr == null) {
            throw new OperatorException(AbstractMetadata.MISSION + " not found");
        }

        missionType = missionTypeAttr.getData().getElemString();
        //System.out.println("Mission is " + missionType);

        if (!missionType.contains("ERS1") && !missionType.contains("ERS2")) {
            throw new OperatorException(missionType + " is not a valid mission for ERS Calibration");
        }

        if(missionType.equals("ERS1"))
            isERS1Mission = true;
    }

    /**
     * Get the sample type.
     */
    private void getSampleType() {

        final MetadataAttribute sampleTypeAttr = abstractedMetadata.getAttribute(AbstractMetadata.SAMPLE_TYPE);
        if (sampleTypeAttr == null) {
            throw new OperatorException(AbstractMetadata.SAMPLE_TYPE + " not found");
        }

        sampleType = sampleTypeAttr.getData().getElemString();
        //System.out.println("Sample type is " + sampleType);

        if(sampleType.contains("DETECTED"))
            isDetectedSampleType = true;
    }

    /**
     * Get Product type.
     */
    private void getProductType() {

        final MetadataAttribute productTypeAttr = abstractedMetadata.getAttribute(AbstractMetadata.PRODUCT_TYPE);
        if (productTypeAttr == null) {
            throw new OperatorException(AbstractMetadata.PRODUCT_TYPE + " not found");
        }

        productType = productTypeAttr.getData().getElemString();

        if (productType.contains("ERS")) {
            isCEOSFormat = true;
        } else if (productType.contains("SAR")) {
            isCEOSFormat = false;
        } else {
            throw new OperatorException("Invalid product type: " + productType);
        }
        //System.out.println("product type is " + productType);
    }

    /**
     * Get the processing facility identifier.
     */
    private void getProcessingFacilityIDFromCEOS() {

        // Field 81 in PRI Data Set Summary Record
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Scene Parameters");
        if (facility == null) {
            throw new OperatorException("Scene Parameters not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Processing facility identifier");
        if (attr == null) {
            throw new OperatorException("Processing facility identifier not found");
        }

        pafID = attr.getData().getElemString();
        /*
        if (!pafID.contains(ESRIN) && !pafID.contains(D_PAF) && !pafID.contains(I_PAF) && !pafID.contains(UK_PAF)) {
            throw new OperatorException("Invalid processing facility identifier: " + pafID);
        }
        */
        //System.out.println("Processing facility identifier is " + pafID);
    }

    /**
     * Get the processing system identifier.
     */
    private void getProcessingSystemID() {

        final MetadataAttribute attr = abstractedMetadata.getAttribute(AbstractMetadata.ProcessingSystemIdentifier);
        if (attr == null) {
            throw new OperatorException(AbstractMetadata.ProcessingSystemIdentifier + " not found");
        }

        psID = attr.getData().getElemString();
        /*
        if (isCEOSFormat) {
            if (!psID.contains("VMP") && !psID.contains("PGS")) {
                throw new OperatorException("Invalid processing system identifier: " + psID);
            }
        } else { // ENVISAT
            psID = "PGS";
        }
        */
        //System.out.println("Processing system identifier is " + psID);
    }

    /**
     * Get the processing version identifier.
     */
    private void getProcessingVersionID() {

        // Field 83 in PRI Data Set Summary Record
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Scene Parameters");
        if (facility == null) {
            throw new OperatorException("Scene Parameters not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Processing version identifier");
        if (attr == null) {
            throw new OperatorException("Processing version identifier not found");
        }

        pvID = attr.getData().getElemString();
        //System.out.println("Processing version identifier is " + pvID);
    }

    /**
     * Get the product acquisition time (in second).
     */
    private void getProductAcquisitionTime() {
        try {
            final ProductData.UTC acqTimeUTC = abstractedMetadata.getAttributeUTC(AbstractMetadata.first_line_time);
            acquisitionTime = acqTimeUTC.getAsDate();
            //System.out.println("The acquisition time is " + acquisitionTime);
        } catch(Exception e) {
            throw new OperatorException(e.getMessage());
        }
    }

    /**
     * Get the processing time (in second).
     */
    private void getProcessingTime() {
        try {
            final ProductData.UTC procTimeUTC = abstractedMetadata.getAttributeUTC(AbstractMetadata.PROC_TIME);
            processingTime = procTimeUTC.getAsDate();
        } catch(Exception e) {
            throw new OperatorException(e.getMessage());
        }
    }

    /**
     * Get the range and azimuth spacings (in meter).
     */
    private void getPixelSpacings() {

        final MetadataAttribute rangeSpacingAttr = abstractedMetadata.getAttribute(AbstractMetadata.range_spacing);
        if (rangeSpacingAttr == null) {
            throw new OperatorException(AbstractMetadata.range_spacing + " not found");
        }

        rangeSpacing = rangeSpacingAttr.getData().getElemFloat();
        //System.out.println("Range spacing is " + rangeSpacing);

        final MetadataAttribute azimuthSpacingAttr = abstractedMetadata.getAttribute(AbstractMetadata.azimuth_spacing);
        if (azimuthSpacingAttr == null) {
            throw new OperatorException(AbstractMetadata.azimuth_spacing + " not found");
        }

        azimuthSpacing = azimuthSpacingAttr.getData().getElemFloat();
        //System.out.println("Azimuth spacing is " + azimuthSpacing);
    }

    /**
     * Get the antenna pattern correction flag and range spreading loss flag.
     */
    private void getCalibrationFlags() {

        final MetadataAttribute absCalibrationFlagAttr = abstractedMetadata.getAttribute(AbstractMetadata.abs_calibration_flag);
        if (absCalibrationFlagAttr == null) {
            throw new OperatorException(AbstractMetadata.abs_calibration_flag + " not found");
        }

        if (absCalibrationFlagAttr.getData().getElemBoolean()) {
            throw new OperatorException("The product has already been calibrated");
        }

        final MetadataAttribute antElevCorrFlagAttr = abstractedMetadata.getAttribute(AbstractMetadata.ant_elev_corr_flag);
        if (antElevCorrFlagAttr == null) {
            throw new OperatorException(AbstractMetadata.ant_elev_corr_flag + " not found");
        }
        antennaPatternCorrectionFlag = antElevCorrFlagAttr.getData().getElemBoolean();
        //System.out.println("Antenna pattern correction flag is " + antennaPatternCorrectionFlag);

        final MetadataAttribute rangeSpreadCompFlagAttr =
                abstractedMetadata.getAttribute(AbstractMetadata.range_spread_comp_flag);
        if (rangeSpreadCompFlagAttr == null) {
            throw new OperatorException(AbstractMetadata.range_spread_comp_flag + " not found");
        }
        rangeSpreadingLossCompFlag = rangeSpreadCompFlagAttr.getData().getElemBoolean();
        //System.out.println("Range spreding loss compensation flag is " + rangeSpreadingLossCompFlag);

        // replica pulse power compensation flag???
    }

    /**
     * Set correction flags.
     */
    private void setCorrectionFlags() {

        applyAntennaPatternCorrection = false;
        applyRangeSpreadingLossCorrection = false;
        applyReplicaPowerCorrection = false;
        applyADCSaturationCorrection = false;

        if (isERS1Mission) { // ERS-1

            if (isDetectedSampleType) { // detected

                //if (!antennaPatternCorrectionFlag) {
                //    applyAntennaPatternCorrection = true;
                //}
                applyReplicaPowerCorrection = true;
                applyADCSaturationCorrection = true;

            } else { // complex

                if (!antennaPatternCorrectionFlag) {
                    applyAntennaPatternCorrection = true;
                }
                if (!rangeSpreadingLossCompFlag) {
                    applyRangeSpreadingLossCorrection = true;
                }
                applyReplicaPowerCorrection = true;
                applyADCSaturationCorrection = true;
            }

        } else { // ERS-2

            if (isDetectedSampleType) { // detected

                applyADCSaturationCorrection = true;

            } else { // complex

                if (!antennaPatternCorrectionFlag) {
                    applyAntennaPatternCorrection = true;
                }
                if (!rangeSpreadingLossCompFlag) {
                    applyRangeSpreadingLossCorrection = true;
                }
                applyADCSaturationCorrection = true;
            }
        }
    }

    /**
     * Get the calibration constant.
     */
    private void getCalibrationConstantFromCEOS() {
        // Field 62 in PRI Facility Related Data Record
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Facility Related");
        if (facility == null) {
            throw new OperatorException("Facility Related not found");
        }

        final MetadataAttribute calibrationConstantAttr = facility.getAttribute("Absolute calibration constant K");
        if (calibrationConstantAttr == null) {
            throw new OperatorException("Absolute calibration constant K not found");
        }

        calibrationConstant = calibrationConstantAttr.getData().getElemFloat();
        //System.out.println("Calibration constant is " + calibrationConstant);
    }

    /**
     * Get the scene centre latitude (in degree).
     */
    private void getSceneCentreLatitude() {
        // Field 13 in PRI Data Set Summary Record (in degree)
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Scene Parameters");
        if (facility == null) {
            throw new OperatorException("Scene Parameters not found");
        }

        final MetadataAttribute attr = facility.getAttribute("scene centre geodetic latitude");
        if (attr == null) {
            throw new OperatorException("Scene centre geodetic latitude not found");
        }

        sceneCentreLatitude = attr.getData().getElemFloat();
        //System.out.println("Scene centre geodetic latitude is " + sceneCentreLatitude);
    }

    /**
     * Read ERS-1 or ERS-2 antenna pattern from files.
     */
    private void getAntennaPatternFromFile () {

        if (isERS1Mission) { // ERS-1

            if (psID.contains(VMP)) {

                if (processingTime.compareTo(time19920901) >= 0 && processingTime.compareTo(time19950716) < 0 &&
                    (pafID.contains(ESRIN) || pafID.contains(D_PAF) || pafID.contains(I_PAF) || pafID.contains(UK_PAF))) {
                    getInitialERS1ElevAntPat();
                }

                if (processingTime.compareTo(time19910801) >= 0) {
//                && (pafID.contains(ESRIN) || pafID.contains(D_PAF) || pafID.contains(I_PAF) || pafID.contains(UK_PAF))) {
                    getImprovedERS1ElevAntPat();
                }

                if (processingTime.compareTo(time19920901) >= 0 && processingTime.compareTo(time19930408) <= 0 &&
                    pafID.contains(UK_PAF)) {
                    getUKPAFElevAntPatCor();
                }

            } else { // PGS (CEOS or ENVISAT)

                // get antenna pattern from ERS1 XCA file
                String fileName = Settings.instance().get("AuxData/ersAuxDataPath") + File.separator +
                                  "ER1_XCA_AXNXXX20050321_000000_19910101_000000_20100101_000000.txt";

                getAntennaPatternGainFromAuxData(fileName);

                extXCAFileName = "ER1_XCA_AXNXXX20050321_000000_19910101_000000_20100101_000000.txt";
                useExtXCAFile = true;
            }

        } else { // ERS-2

            if (psID.contains(VMP)) {

                getERS2ElevAntPat();

            } else { // PGS (CEOS or ENVISAT)

                // get antenna pattern from ERS2 XCA file
                String fileName = Settings.instance().get("AuxData/ersAuxDataPath") + File.separator +
                                  "ER2_XCA_AXNXXX20050321_000000_19950101_000000_20100101_000000.txt";

                getAntennaPatternGainFromAuxData(fileName);

                extXCAFileName = "ER2_XCA_AXNXXX20050321_000000_19950101_000000_20100101_000000.txt";
                useExtXCAFile = true;
            }
        }
    }

    /**
     * Get the initial ERS-1 SAR antenna pattern (Appendix G1).
     */
    private void getInitialERS1ElevAntPat() {

        // The following time checking is ignored. See Andrea's email dated Sep. 15, 2008.
        //if (processingTime.compareTo(time19950716) >= 0) {
        //    throw new OperatorException("Processing date must be earlier than 16-July-1995");
        //}

        final String fileName = "Appendix_G1.txt";
        appendixG1 = readFile(getERSAuxFile(fileName).getAbsolutePath());
    }

    /**
     * Get the improved ERS-1 SAR antenna pattern (Appendix G2).
     */
    private void getImprovedERS1ElevAntPat() {

        String fileName = "";
        if (processingTime.compareTo(time19950716) >= 0 && pvID.compareTo("6.8") < 0) {
            fileName ="Appendix_G2_b.txt";
        } else if (pvID.compareTo("6.8") >= 0) {
            fileName ="Appendix_G2_c.txt";
        } else {
            throw new OperatorException("The operator does not support VMP product processed before 1995-07-16");
        }

        final File file = getERSAuxFile(fileName);
        appendixG2 = readFile(file.getAbsolutePath());
    }

    /**
     * Get the UK-PAF ERS-1 antenna pattern (Appendix H).
     */
    private void getUKPAFElevAntPatCor() {

        String fileName = "";
        if (acquisitionTime.compareTo(time19920401) <= 0) { //orbit repeat period: 3 days;
            fileName = "Appendix_H_1.txt";
        } else if (acquisitionTime.compareTo(time19920414) >= 0 && acquisitionTime.compareTo(time19930408) <= 0) { //orbit repeat period: 35 days;
            fileName = "Appendix_H_2.txt";
        } else {
            throw new OperatorException("Incorrect acquisition date");
        }

        final File file = getERSAuxFile(fileName);
        appendixH = readFile(file.getAbsolutePath());
    }

    /**
     * Get the ERS-2 antenna pattern (Appendix G3).
     */
    private void getERS2ElevAntPat() {

        String fileName = "";
        if (pvID.compareTo("6.8") < 0) {
            fileName ="Appendix_G3_b.txt";
        } else if (pvID.compareTo("6.8") >= 0) {
            fileName ="Appendix_G3_c.txt";
        }

        File file = getERSAuxFile(fileName);
        appendixG3 = readFile(file.getAbsolutePath());
    }

    private static File getERSAuxFile(final String fileName) {
        final String homeUrl = System.getProperty("nest.home", ".");
        final String path = homeUrl + File.separator + "auxdata" + File.separator + "ers" + File.separator + fileName;
        return new File(path);
    }

    /**
     * Read antenna pattern data from file and save them in a 2D array.
     *
     * @param fileName The file name
     * @return array The 2D array holding antenna pattern data
     */
    private static double[][] readFile(final String fileName) {

        // get reader
        FileInputStream stream;
        try {
            stream = new FileInputStream(fileName);
        } catch(FileNotFoundException e) {
            throw new OperatorException("File not found: " + fileName);
        }

        final BufferedReader reader = new BufferedReader(new InputStreamReader(stream));

        // read data from file and save them in 2-D array
        String line = "";
        StringTokenizer st;
        double[][] array;
        int rowIdx = 0;

        try {
            // get the 1st line
            if ((line = reader.readLine()) == null) {
                throw new OperatorException("Empty file: " + fileName);
            }

            st = new StringTokenizer(line);
            if (st.countTokens() != 2) {
                throw new OperatorException("Incorrect file format: " + fileName);
            }

            final int numRows = Integer.parseInt(st.nextToken());
            final int numCols = Integer.parseInt(st.nextToken());
            array = new double[numRows][numCols];

            // get the rest numRows lines
            while((line = reader.readLine()) != null) {

                st = new StringTokenizer(line);
                if (st.countTokens() != numCols) {
                    throw new OperatorException("Incorrect file format: " + fileName);
                }

                for (int j = 0; j < numCols; j++) {
                    array[rowIdx][j] = Double.parseDouble(st.nextToken());
                }
                rowIdx++;
            }

            if (numRows != rowIdx) {
                throw new OperatorException("Incorrect number of lines in file: " + fileName);
            }

            reader.close();
            stream.close();

        } catch (IOException e) {
            throw new OperatorException(e);
        }
        return array;
    }

    /**
     * Obtain from auxiliary data the elevation angles for given swath and the antenna elevation
     * pattern gains for the swath and the polarization of the product.
     *
     * @param fileName The auxiliary data file name.
     */
    private void getAntennaPatternGainFromAuxData(String fileName) throws OperatorException {

        final EnvisatAuxReader reader = new EnvisatAuxReader();

        try {
            reader.readProduct(fileName);

            final ProductData elevAngleData = reader.getAuxData("elev_ang_is2");
            elevationAngle = (double) elevAngleData.getElemFloat();
            //System.out.println("elevation angle is " + elevationAngle);
            //System.out.println();

            final ProductData patData = reader.getAuxData("pattern_is2");
            final float[] pattern = ((float[]) patData.getElems());

            if (pattern.length != 804) {
                throw new OperatorException("Incorrect array length for pattern_is2");
            }

            final int numOfGains = 201;
            antPatForPGS = new float[numOfGains];
            System.arraycopy(pattern, numOfGains, antPatForPGS, 0, numOfGains); // polarization = VV
            /*
            for (float val : antPatForPGS) {
                System.out.print(val + ", ");
            }
            System.out.println();
            */
        } catch (IOException e) {
            throw new OperatorException(e);
        }
    }

    /**
     * Get chirp average density image.
     *
     * @return The chirp average density image.
     */
    private static double getChirpAverageDensityImage() {
        // Byte location 3449 in "ESA reserved" record in Facility Data Record, PCS type
        // need to read chirp average density image (see Appendix D3 on p27)

        return 267.20;
    }

    /**
     * Compute replica pulse variations correction factor.
     */
    private void computeReplicaPulseVariationsCorrectionFactor() {

        final double replicaPulsePower;
        if (isCEOSFormat) {
            replicaPulsePower = getReplicaPulsePowerForCEOS();
        } else { // ENVISAT
            replicaPulsePower = getReplicaPulsePowerForENVISAT();
        }

        if (Double.compare(replicaPulsePower, -9999999.9999999) == 0 ||
            Double.compare(replicaPulsePower, 0.0) == 0) {
            replicaPulseVariationsCorrectionFactor = 1.0;
        } else {
            if (isERS1Mission) {
                replicaPulseVariationsCorrectionFactor = replicaPulsePower / 205229.0;
            } else {
                replicaPulseVariationsCorrectionFactor = replicaPulsePower / 156000.0;
            }
        }
        /*
        if (isERS1Mission) {

            if (pafID.contains(D_PAF) || pafID.contains(I_PAF) || pafID.contains(UK_PAF)) {

                if (Double.compare(replicaPulsePower, -9999999.9999999) == 0) {
                    if (pafID.contains(D_PAF)) {
                        replicaPulseVariationsCorrectionFactor = getChirpAverageDensityImage() / 267.20;
                    } else {
                        throw new OperatorException("Replica pulse power is not available");
                    }
                } else {
                    replicaPulseVariationsCorrectionFactor = replicaPulsePower / 205229.0;
                }

            } else if (pafID.contains(ESRIN)) {
                replicaPulseVariationsCorrectionFactor = getChirpAverageDensityImage() / 267.20;
            }

        } else { // ERS-2

            if (pafID.contains(D_PAF) || pafID.contains(I_PAF) || pafID.contains(UK_PAF) || pafID.contains(ESRIN)) {

                if (Double.compare(replicaPulsePower, -9999999.9999999) == 0) {
                    throw new OperatorException("Replica pulse power is not available");
                }
                replicaPulseVariationsCorrectionFactor = replicaPulsePower / 156000.0;
            }
        }
        */
    }

    /**
     * Get the replica pulse power for CEOS product.
     * @return The replica pulse power
     */
    private double getReplicaPulsePowerForCEOS() {
        // Field 55 in PRI Facility Related Data Record
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Facility Related");
        if (facility == null) {
            throw new OperatorException("Facility Related not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Replica pulse power");
        if (attr == null) {
            throw new OperatorException("Replica pulse power");
        }

        return attr.getData().getElemFloat();
    }

    /**
     * Compute incidence angles (in radian), look angles (in radian) and range spreading loss
     * for pixels in a complete range line.
     */
    private void computeIncidenceAnglesLookAnglesRangeSpreadingLossForCEOS() {

        incidenceAngles = new double[sourceImageWidth];
        lookAngles = new double[sourceImageWidth];
        rangeSpreadingLoss = new double[sourceImageWidth];

        double a;
        double b;
        if (psID.contains(VMP)) {
            a = aGEM6;
            b = bGEM6;
        } else { // PGS
            a = aWGS84;
            b = bWGS84;
        }
        final double lambda = sceneCentreLatitude * MathUtils.DTOR;
        final double alpha1 = getIncidenceAngleAtFirstRangePixel() * MathUtils.DTOR;
        final double cos2 = Math.pow(Math.cos(lambda), 2.0);
        final double sin2 = Math.pow(Math.sin(lambda), 2.0);
        final double e2 = Math.pow(b/a, 2.0);
        final double rt = a*Math.sqrt((cos2 + e2*e2*sin2)/(cos2 + e2*sin2));
        final double rt2 = rt*rt;

        double groundRangeSpacing;
        if (isDetectedSampleType) {
            groundRangeSpacing = rangeSpacing;
        } else {
            groundRangeSpacing = rangeSpacing / Math.sin(alpha1);
        }

        double deltaPsi = groundRangeSpacing/rt; // in radian

        double rtPlusH = 0.0;
        double rtPlusH2 = 0.0;
        double theta1 = 0.0;
        double psi1 = 0.0;
        double psi = 0.0;
        double alpha = 0.0;
        double ri = 0.0;
        if (!pafID.contains(UK_PAF) || processingTime.compareTo(time19930408) >= 0) {

            // Method 1 in Appendix B1
            final double r1 = halfLightSpeed * getZeroDopplerTimeOfFirstRangePixel();
            rtPlusH = Math.sqrt(rt2 + r1*r1 + 2.0*rt*r1*Math.cos(alpha1));
            rtPlusH2 = rtPlusH*rtPlusH;
            theta1 = Math.acos((r1 + rt*Math.cos(alpha1))/rtPlusH);
            psi1 = alpha1 - theta1;
            psi = psi1;
            for (int i = 0; i < sourceImageWidth; i++) {
                psi = psi + deltaPsi;
                ri = Math.sqrt(rt2 + rtPlusH2 - 2.0*rt*rtPlusH*Math.cos(psi));
                alpha = Math.acos((rtPlusH2 - ri*ri - rt2)/(2.0*ri*rt));
                incidenceAngles[i] = alpha;
                lookAngles[i] = Math.acos((ri + rt*Math.cos(alpha))/rtPlusH);
                rangeSpreadingLoss[i] = Math.pow(ri/referenceSlantRange, 3.0);

                if (!isDetectedSampleType) {
                    groundRangeSpacing = rangeSpacing / Math.sin(alpha);
                    deltaPsi = groundRangeSpacing/rt;
                }
            }

        } else { // For UK-PAF products processed prior to 8th April 1993

            // Method 2 in Appendix B2
            final double del = getTimeIntervalBetweenDataPoints();
            final double firstLineTime = getZeroDopplerAzimuthTimeOfFirstAzimuthPixel();
            final double middleLineTime = getZeroDopplerAzimuthTimeOfCentreAzimuthPixel();
            final int k = (int)((middleLineTime - firstLineTime) / del + 0.5);
            final double[] positionVector = new double[3];
            getPositionVector(k, positionVector);
            double x = positionVector[0];
            double y = positionVector[1];
            double z = positionVector[2];
            rtPlusH = Math.sqrt(x*x + y*y + z*z);
            rtPlusH2 = rtPlusH*rtPlusH;
            theta1 = Math.asin(Math.sin(alpha1)*rt/rtPlusH);
            psi1 = alpha1 - theta1;
            psi = psi1;
            for (int i = 0; i < sourceImageWidth; i++) {
                psi = psi + Math.asin(deltaPsi);
                ri = Math.sqrt(rt2 + rtPlusH2 - 2.0*rt*rtPlusH*Math.cos(psi));
                alpha = Math.acos((rtPlusH2 - ri*ri - rt2)/(2.0*ri*rt));
                incidenceAngles[i] = alpha;
                lookAngles[i] = Math.asin(Math.sin(alpha)*rt/rtPlusH);
                rangeSpreadingLoss[i] = Math.pow(ri/referenceSlantRange, 3.0);

                if (!isDetectedSampleType) {
                    groundRangeSpacing = rangeSpacing / Math.sin(alpha);
                    deltaPsi = groundRangeSpacing/rt;
                }
            }
        }
        /*
        for (int i = 0; i < sourceImageWidth; i=i+20) {
            System.out.print(incidenceAngles[i] + ", ");
        }
        System.out.println();
        for (int i = 0; i < sourceImageWidth; i=i+20) {
            System.out.print(lookAngles[i] + ", ");
        }
        System.out.println();
        for (int i = 0; i < sourceImageWidth; i=i+20) {
            System.out.print(rangeSpreadingLoss[i] + ", ");
        }
        System.out.println();
        */
    }

    /**
     * Get the incidence angle at the first range pixel (in degree).
     * @return The incidence angle.
     */
    private double getIncidenceAngleAtFirstRangePixel() {
        // Field 56 in PRI Facility Related Data Record (in degree)
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Facility Related");
        if (facility == null) {
            throw new OperatorException("Facility Related not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Incidence angle at first range pixel");
        if (attr == null) {
            throw new OperatorException("Incidence angle at first range pixel not found");
        }
        //System.out.println("Incidence angle at first range pixel is " + incidenceAngleAtFirstRangePixel);

        return attr.getData().getElemFloat();
    }

    /**
     * Get the zero doppler range time of the first range pixel (in second).
     * @return The zero doppler time.
     */
    private double getZeroDopplerTimeOfFirstRangePixel() {
        // Field 126/1 in PRI Data Set Summary Record (in millisec)
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Scene Parameters");
        if (facility == null) {
            throw new OperatorException("Scene Parameters not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Zero-doppler range time of first range pixel");
        if (attr == null) {
            throw new OperatorException("Zero-doppler range time of first range pixel not found");
        }
        //System.out.println("Zero-doppler range time of first range pixel is " + zeroDopplerTimeOfFirstRangePixel);

        return attr.getData().getElemFloat() / 1000.0; // millisec to s
    }

    /**
     * Get the time interval between data points (in second).
     * @return The time interval.
     */
    private double getTimeIntervalBetweenDataPoints() {

        // Field 20 in PRI Platform Position Data Set Record (in s)
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Platform Position");
        if (facility == null) {
            throw new OperatorException("Platform Position not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Time interval between data points");
        if (attr == null) {
            throw new OperatorException("Time interval between data points not found");
        }

        return attr.getData().getElemDouble();
    }

    /**
     * Get the zero doppler azimuth time of the first azimuth pixel (in second).
     * @return The zero doppler time.
     */
    private double getZeroDopplerAzimuthTimeOfFirstAzimuthPixel() {
        // Field 126/5 in PRI Data Set Summary Record (in UTC)
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Scene Parameters");
        if (facility == null) {
            throw new OperatorException("Scene Parameters not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Zero-doppler azimuth time of first azimuth pixel");
        if (attr == null) {
            throw new OperatorException("Zero-doppler azimuth time of first azimuth pixel not found");
        }

        return convertUTCTimes(attr.getData().getElemString()); // in s
    }

    /**
     * Get the zero doppler azimuth time of the centre azimuth pixel (in second).
     * @return The zero doppler time.
     */
    private double getZeroDopplerAzimuthTimeOfCentreAzimuthPixel() {
        // Field 126/5 in PRI Data Set Summary Record (in UTC)
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Scene Parameters");
        if (facility == null) {
            throw new OperatorException("Scene Parameters not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Zero-doppler azimuth time of centre azimuth pixel");
        if (attr == null) {
            throw new OperatorException("Zero-doppler azimuth time of centre azimuth pixel not found");
        }

        return convertUTCTimes(attr.getData().getElemString()); // in s
    }

    /**
     * Get the position vector for the kth data point.
     *
     * @param k The data point index
     * @param array The length-3 1D array holding position coordinates (x,y,z)
     */
    private void getPositionVector(int k, double[] array) {

        if (k > getNumOfDataPoints()) {
            throw new OperatorException("Invalid data point index");
        }

        // Fields 29 to (29 + number of data points) in PRI Platform Position Data Set Record
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Platform Position");
        if (facility == null) {
            throw new OperatorException("Platform Position not found");
        }

        final MetadataAttribute xAttr = facility.getAttribute("Position vector X " + k);
        if (xAttr == null) {
            throw new OperatorException("Position vector X " + k + " not found");
        }

        final MetadataAttribute yAttr = facility.getAttribute("Position vector Y " + k);
        if (yAttr == null) {
            throw new OperatorException("Position vector X " + k + " not found");
        }

        final MetadataAttribute zAttr = facility.getAttribute("Position vector Z " + k);
        if (zAttr == null) {
            throw new OperatorException("Position vector Y " + k + " not found");
        }

        array[0] = xAttr.getData().getElemDouble();
        array[1] = yAttr.getData().getElemDouble();
        array[2] = zAttr.getData().getElemDouble();
    }

    /**
     * Get the number of data points.
     * @return The number of data points.
     */
    private int getNumOfDataPoints() {

        // Field 14 in PRI Platform Position Data Set Record
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Platform Position");
        if (facility == null) {
            throw new OperatorException("Platform Position not found");
        }

        final MetadataAttribute attr = facility.getAttribute("Number of data points");
        if (attr == null) {
            throw new OperatorException("Number of data points not found");
        }

        return attr.getData().getElemInt();
    }

    /**
     * Update the metadata in the target product.
     */
    private void updateTargetProductMetadata() {

        final MetadataElement abs = targetProduct.getMetadataRoot().getElement("Abstracted Metadata");

        if (!isDetectedSampleType) {
            final MetadataAttribute sampleTypeAttr = abs.getAttribute(AbstractMetadata.SAMPLE_TYPE);
            abs.removeAttribute(sampleTypeAttr);
            abs.addAttribute(new MetadataAttribute(AbstractMetadata.SAMPLE_TYPE,
                    ProductData.createInstance("DETECTED"), false));
        }

        // update antenna pattern correction flag
        if (applyAntennaPatternCorrection) {
            abs.getAttribute(AbstractMetadata.ant_elev_corr_flag).getData().setElemBoolean(true);
        }

        // update range spreading loss correction flag
        if (applyRangeSpreadingLossCorrection) {
            abs.getAttribute(AbstractMetadata.range_spread_comp_flag).getData().setElemBoolean(true);
        }

        // update replica pulse power correction flag
        if (applyReplicaPowerCorrection) {
            abs.getAttribute(AbstractMetadata.replica_power_corr_flag).getData().setElemBoolean(true);
        }

        // update abs_calibration_flag
        abs.getAttribute(AbstractMetadata.abs_calibration_flag).getData().setElemBoolean(true);

        // update XCA file name
        if (useExtXCAFile == true) {
            MetadataAttribute attr = abs.getAttribute(AbstractMetadata.external_calibration_file);
            abs.removeAttribute(attr);
            abs.addAttribute(new MetadataAttribute(AbstractMetadata.external_calibration_file,
                                                   ProductData.createInstance(extXCAFileName),
                                                   false));
        }
    }

    /**
     * Compute the antenna pattern correction facotrs for a range line in current tile.
     * @param x0 The x coordinate for the pixel at the upper left corner
     * @param w The width of the tile
     */
    private void computeAntennaPatternCorrectionFactors(int x0, int w) {

        antennaPatternCorrFactor = new double[w];

        if (psID.contains(VMP)) {
            computeAntennaPatternCorrectionFactorsForVMPProduct(x0, w);
        } else { // PGS (CEOS or ENVISAT)
            computeAntennaPatternCorrectionFactorsForPGSProduct(x0, w);
        }
    }

    private void computeAntennaPatternCorrectionFactorsForVMPProduct(int x0, int w) {

        if (processingTime.compareTo(time19950716) >= 0) {
            for (int x = x0; x < x0 + w; x++) {
                antennaPatternCorrFactor[x - x0] = 1.0;
            }
            return;
        }

        double theta = 0.0;

        if (isERS1Mission) { // ERS-1

            if (pafID.contains(ESRIN) || pafID.contains(D_PAF) || pafID.contains(I_PAF)) {

                if (processingTime.compareTo(time19910801) >= 0 && processingTime.compareTo(time19920901) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        theta = lookAngles[x] * MathUtils.RTOD; // in degree
                        antennaPatternCorrFactor[x - x0] = 1.0 / g2Im(theta);
                    }

                } else if (processingTime.compareTo(time19920901) >= 0 && processingTime.compareTo(time19950716) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        theta = lookAngles[x] * MathUtils.RTOD; // in degree
                        antennaPatternCorrFactor[x - x0] = g2Init(theta) / g2Im(theta);
                    }

                }
                /*
                else if (processingTime.compareTo(time19950716) >= 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        antennaPatternCorrFactor[x - x0] = 1.0;
                    }
                }
                */

            } else if (pafID.contains(UK_PAF)) {

                if (processingTime.compareTo(time19910801) >= 0 && processingTime.compareTo(time19920901) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        theta = lookAngles[x] * MathUtils.RTOD; // in degree
                        antennaPatternCorrFactor[x - x0] = 1.0 / g2Im(theta);
                    }

                } else if (processingTime.compareTo(time19920901) >= 0 && processingTime.compareTo(time19930408) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        theta = lookAngles[x] * MathUtils.RTOD; // in degree
                        antennaPatternCorrFactor[x - x0] = ec(theta) * g2Init(theta) / g2Im(theta);
                    }

                } else if (processingTime.compareTo(time19930408) >= 0 && processingTime.compareTo(time19950716) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        theta = lookAngles[x] * MathUtils.RTOD; // in degree
                        antennaPatternCorrFactor[x - x0] = g2Init(theta) / g2Im(theta);
                    }

                }
                /*
                else if (processingTime.compareTo(time19950716) >= 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        antennaPatternCorrFactor[x - x0] = 1.0;
                    }
                }
                */
            }

        } else { // ERS-2

            //if (processingTime.compareTo(time19951016) >= 0) {

                for (int x = x0; x < x0 + w; x++) {
                    antennaPatternCorrFactor[x - x0] = 1.0;
                }
            //}
        }
    }


    private void computeAntennaPatternCorrectionFactorsForPGSProduct(int x0, int w) {

        final double[] antennaPatternGain = new double[w];
        getPGSAntennaPatternGainForCurrentTile(x0, w, antennaPatternGain);

        for (int x = x0; x < x0 + w; x++) {
            antennaPatternCorrFactor[x - x0] = 1.0 / antennaPatternGain[x - x0];
        }
    }

    private void getPGSAntennaPatternGainForCurrentTile(int x0, int w, double[] array) {

        final double delta = 0.05;

        for (int x = x0; x < x0 + w; x++) {

            final double theta = lookAngles[x] * MathUtils.RTOD; // in degree
            final int k = (int) ((theta - elevationAngle + 5.0) / delta);
            final double theta1 = elevationAngle - 5.0 + k * delta;
            final double theta2 = theta1 + delta;
            final double gain1 = Math.pow(10.0, (double) antPatForPGS[k] / 10.0); // convert dB to linear scale
            final double gain2 = Math.pow(10.0, (double) antPatForPGS[k + 1] / 10.0);
            array[x - x0] = ((theta2 - theta) * gain1 + (theta - theta1) * gain2) / (theta2 - theta1);

            /*
            System.out.println("Reference elevation angle is " + elevationAngle);
            System.out.println("Pixel elevation angle is " + theta);
            System.out.println("theta1 = " + theta1);
            System.out.println("theta2 = " + theta2);
            System.out.println("gain1 = " + pattern[k]);
            System.out.println("gain2 = " + pattern[k+1]);
            System.out.println("gain = " + targetTileNewAntPat[x - x0]);
            */
        }
    }

    /**
     * Compute the initial ERS-1 antenna pattern (Appendix G1) for given look angle.
     * @param lookAngle The look angle (in degree)
     * @return The antenna pattern gain (in linear scale)
     */
    private double g2Init(double lookAngle) {

        return getAntennaPatternGain(lookAngle, appendixG1);
    }

    /**
     * Compute the improved ERS-1 antenna pattern (Appendix G2(a)(b)(c)) for given look angle.
     * @param lookAngle The look angle (in degree)
     * @return The antenna pattern gain (in linear scale)
     */
    private double g2Im(double lookAngle) {

        return getAntennaPatternGain(lookAngle, appendixG2);
    }

    /**
     * Compute the ERS-2 antenna pattern (Appendix G3(a)(b)(c)) for given look angle.
     * @param lookAngle The look angle (in degree)
     * @return The antenna pattern gain (in linear scale)
     */
    private double g2ERS2(double lookAngle) {

        return getAntennaPatternGain(lookAngle, appendixG3);
    }

    /**
     * Compute initial or improved ERS-1 antenna pattern (Appendix G1 or G2) for given look angle.
     * @param lookAngle The look angle (in degree)
     * @param array 2-D array holding antenna pattern data given in Appendix G1 or G2
     * @return The antenna pattern gain (in linear scale)
     */
    private static double getAntennaPatternGain(double lookAngle, double[][] array) {

        final int numRows = array.length;
        final int numCols = array[0].length;
        if (numCols != 2) {
            throw new OperatorException("Incorrect array dimension");
        }

        final double boreSightAngle = lookAngle - relativeLookAngle;
        int row1 = 0;
        int row2 = 0;
        if (boreSightAngle < array[0][0]) {
            row1 = 0;
            row2 = 1;
        } else if (boreSightAngle > array[numRows-1][0]) {
            row1 = numRows - 2;
            row2 = numRows - 1;
        } else {
            for (int i = 1; i < numRows; i++) {
                if (boreSightAngle < array[i][0]) {
                    row1 = i - 1;
                    row2 = i;
                    break;
                }
            }
        }

        final double delTheta1 = array[row1][0];
        final double delTheta2 = array[row2][0];
        final double gain1 = array[row1][1];
        final double gain2 = array[row2][1];
        final double lambda = (boreSightAngle - delTheta1) / (delTheta2 - delTheta1);
        double gain = ((1 - lambda)*gain1 + lambda*gain2);
        gain = Math.pow(10, gain / 10.0); // dB to linear scale

        return gain;
    }

    /**
     * Compute the UK-PAF ERS-1 antenna pattern (Appendix H) for given look angle.
     * @param lookAngle The look angle (in degree)
     * @return The antenna pattern gain (in linear scale)
     */
    private double ec(double lookAngle) {

        final int numRows = appendixH.length;
        final int numCols = appendixH[0].length;
        if (numRows < 2 || numCols < 2) {
            throw new OperatorException("Not enough antenna pattern data");
        }

        final double boreSightAngle = lookAngle - relativeLookAngle;

        int row1 = 0;
        int row2 = 0;
        if (sceneCentreLatitude < appendixH[1][0]) {
            row1 = 1;
            row2 = 2;
        } else if (sceneCentreLatitude > appendixH[numRows-1][0]) {
            row1 = numRows - 2;
            row2 = numRows - 1;
        } else {
            for (int i = 2; i < numRows; i++) {
                if (sceneCentreLatitude < appendixH[i][0]) {
                    row1 = i - 1;
                    row2 = i;
                    break;
                }
            }
        }

        int col1 = 0;
        int col2 = 0;
        if (boreSightAngle < appendixH[0][1]) {
            col1 = 1;
            col2 = 2;
        } else if (boreSightAngle > appendixH[numCols-1][0]) {
            col1 = numCols - 2;
            col2 = numCols - 1;
        } else {
            for (int j = 2; j < numCols; j++) {
                if (boreSightAngle < appendixH[0][j]) {
                    col1 = j - 1;
                    col2 = j;
                    break;
                }
            }
        }

        final double lat1 = appendixH[row1][0];
        final double lat2 = appendixH[row2][0];
        final double delTheta1 = appendixH[0][col1];
        final double delTheta2 = appendixH[0][col2];
        if (Double.compare(lat1, lat2) == 0 || Double.compare(delTheta1, delTheta2) == 0) {
            throw new OperatorException("Incorrect latitude or look angle data");
        }

        final double gain11 = appendixH[row1][col1];
        final double gain12 = appendixH[row1][col2];
        final double gain21 = appendixH[row2][col1];
        final double gain22 = appendixH[row2][col2];
        final double lambda1 = (sceneCentreLatitude - lat1) / (lat2 - lat1);
        final double lambda2 = (boreSightAngle - delTheta1) / (delTheta2 - delTheta1);
        double gain = (1 - lambda2)*((1 - lambda1)*gain11 + lambda1*gain21) +
                            lambda2*((1 - lambda1)*gain12 + lambda1*gain22);
        gain = Math.pow(10, gain / 10); // dB to linear scale

        return gain;
    }

//================================================= ADC ======================================================

    private void prepareForADCCorrection() {

        getADCPowerLossCorrLUT();

        windowWidth  = (int)(windowDimInRange / rangeSpacing); // 1200 pixels
        windowHeight = (int)(windowDimInAzimuth / azimuthSpacing); // 400 pixels

        blockWidth = (int)(downSampleBlockSize / rangeSpacing); // 8 pixels
        blockHeight = (int)(downSampleBlockSize / azimuthSpacing); // 8 pixels
    }

    /**
     * Get ADC Power Loss Correction Look-up Table (Appendix F1 or F2).
     */
    private void getADCPowerLossCorrLUT() {

        String fileName;
        if (isERS1Mission) {
            fileName = "Appendix_F1.txt";
        } else {
            fileName = "Appendix_F2.txt";
        }

        final File file = getERSAuxFile(fileName);

        if (isERS1Mission) {
            appendixF1 = readFile(file.getAbsolutePath());
        } else {
            appendixF2 = readFile(file.getAbsolutePath());
        }
    }

    private boolean isADCNeeded(String[] srcBandNames, Unit.UnitType bandUnit, ProgressMonitor pm) {

        final int w = Math.min(windowWidth, sourceImageWidth);
        final int h = Math.min(windowHeight, sourceImageHeight);
        final int x0 = (sourceImageWidth - w)/2;
        final int y0 = (sourceImageHeight - h)/2;

        final Rectangle sourceTileRectangle = new Rectangle(x0, y0, w, h);
        Tile sourceRaster1 = null;
        Tile sourceRaster2 = null;
        if (srcBandNames.length == 1) {
            sourceRaster1 = getSourceTile(sourceBand1, sourceTileRectangle, pm);
        } else {
            sourceRaster1 = getSourceTile(sourceBand1, sourceTileRectangle, pm);
            sourceRaster2 = getSourceTile(sourceBand2, sourceTileRectangle, pm);
        }

        final ProductData srcData1 = sourceRaster1.getDataBuffer();
        ProductData srcData2 = null;
        if(sourceRaster2 != null)
            srcData2 = sourceRaster2.getDataBuffer();

        int index;
        double sigma = 0.0;
        for (int y = y0; y < y0 + h; y++) {
            for (int x = x0; x < x0 + w; x++) {

                index = sourceRaster1.getDataBufferIndex(x, y);

                if (bandUnit == Unit.UnitType.AMPLITUDE) {
                    final double dn = srcData1.getElemDoubleAt(index);
                    sigma += dn*dn;
                } else if (bandUnit == Unit.UnitType.INTENSITY) {
                    sigma += srcData1.getElemDoubleAt(index);
                } else { // COMPLEX
                    final double i = srcData1.getElemDoubleAt(index);
                    final double q = srcData2.getElemDoubleAt(index);
                    sigma += i*i + q*q;
                }
            }
        }
        sigma /= w*h*calibrationConstant;
        if (sigma < underFlowFloat) {
            sigma = Math.min(ers1ApplyADCThreshold, ers2ApplyADCThreshold);
        } else {
            sigma = 10.0 * Math.log10(sigma);
        }

        if (isERS1Mission && sigma <= ers1ApplyADCThreshold) {
            return false;
        }

        if (!isERS1Mission && sigma <= ers2ApplyADCThreshold) {
                return false;
        }

        return true;
    }

    private void computeAntennaPatternGain(int x0, int w) {

        antennaPatternGain = new double[w];

        if (psID.contains(VMP)) {
            computeAntennaPatternGainForVMPProduct(x0, w);
        } else { // PGS (XEOS or ENVISAT)
            computeAntennaPatternGainForPGSProduct(x0, w);
        }
    }

    private void computeAntennaPatternGainForVMPProduct(int x0, int w) {

        double theta = 0.0;

        if (isERS1Mission) {

            if (processingTime.compareTo(time19950716) >= 0) {
                for (int x = x0; x < x0 + w; x++) {
                    theta = lookAngles[x] * MathUtils.RTOD; // in degree
                    antennaPatternGain[x - x0] = g2Im(theta);
                }
                return;
            }

            if (pafID.contains(ESRIN) || pafID.contains(D_PAF) || pafID.contains(I_PAF)) {

                if (processingTime.compareTo(time19910801) >= 0 && processingTime.compareTo(time19920901) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        antennaPatternGain[x - x0] = 1.0;
                    }

                } else if (processingTime.compareTo(time19920901) >= 0 && processingTime.compareTo(time19950716) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        theta = lookAngles[x] * MathUtils.RTOD; // in degree
                        antennaPatternGain[x - x0] = g2Init(theta);
                    }

                }

            } else if (pafID.contains(UK_PAF)) {

                if (processingTime.compareTo(time19910801) >= 0 && processingTime.compareTo(time19920901) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        antennaPatternGain[x - x0] = 1.0;
                    }

                } else if (processingTime.compareTo(time19920901) >= 0 && processingTime.compareTo(time19930408) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        theta = lookAngles[x] * MathUtils.RTOD; // in degree
                        antennaPatternGain[x - x0] = ec(theta) * g2Init(theta);
                    }

                } else if (processingTime.compareTo(time19930408) >= 0 && processingTime.compareTo(time19950716) < 0) {

                    for (int x = x0; x < x0 + w; x++) {
                        theta = lookAngles[x] * MathUtils.RTOD; // in degree
                        antennaPatternGain[x - x0] = g2Init(theta);
                    }

                }
            }

        } else { // ERS-2

            for (int x = x0; x < x0 + w; x++) {
                theta = lookAngles[x] * MathUtils.RTOD; // in degree
                antennaPatternGain[x - x0] = g2ERS2(theta);
            }
        }
    }

    private void computeAntennaPatternGainForPGSProduct(int x0, int w) {

        getPGSAntennaPatternGainForCurrentTile(x0, w, antennaPatternGain);
    }

    private void computeADCPowerLossValuesForCurrentTile(
            int tx0, int ty0, int tw, int th, ProgressMonitor pm, String[] srcBandNames, Unit.UnitType bandUnit) {

        // 1. Get source tile rectangle
        Rectangle sourceTileRectangle = getSourceTileRectangle(tx0, ty0, tw, th);

        // 2. Compute intensity image
        RenderedImage intendityImage = getIntensityImage(sourceTileRectangle, pm, srcBandNames, bandUnit);
        //System.out.println("intendityImage width: " + intendityImage.getWidth());
        //System.out.println("intendityImage height: " + intendityImage.getHeight());
        //outputRealImage(intendityImage, 0, 999);

        // 3. Average intensity image with an 8x8 block.
        RenderedImage downSampledImage = downSampleImage(intendityImage);
        //System.out.println("downSampledImage width: " + downSampledImage.getWidth());
        //System.out.println("downSampledImage height: " + downSampledImage.getHeight());
        //outputRealImage(downSampledImage, 0, 999);

        // 4. Removing original corrections applied: range spreading loss, antenna pattern and replica pulse power.
        RenderedImage rawImage = removeFactorsApplied(downSampledImage);
        //System.out.println("rawImage width: " + rawImage.getWidth());
        //System.out.println("rawImage height: " + rawImage.getHeight());
        //outputRealImage(rawImage, 0, 999);

        // 5. Smooth the raw image with a (1200/8)x(400/8) = 150x50 window.
        RenderedImage smoothedImage = smoothImage(rawImage);
        //System.out.println("smoothedImage width: " + smoothedImage.getWidth());
        //System.out.println("smoothedImage height: " + smoothedImage.getHeight());
        //outputRealImage(smoothedImage, 25000, 25999);

        // 6. Squaring the pixel value and dividing it by calibration constant K.
        RenderedImage squaredImage = getSquaredImage(smoothedImage);
        //System.out.println("squaredImage width: " + squaredImage.getWidth());
        //System.out.println("squaredImage height: " + squaredImage.getHeight());
        //outputRealImage(squaredImage, 25000, 25999);

        // 7. Generating ADC compensation file using look-up table in Appendix F (F1 or F2) and interpolation.
        computeADCPowerLossValue(squaredImage);
    }

    private Rectangle getSourceTileRectangle(int tx0, int ty0, int tw, int th) {

        // The tile height should have window height more pixels than the target tile height
        final int halfWindowHeight = windowHeight/2;
        int sx0 = tx0;
        int sy0 = ty0;
        int sw = tw;
        int sh = th;

        adcSourceTileTopExtFlag = false;
        adcSourceTileBottomExtFlag = false;

        if (ty0 >= halfWindowHeight) {
            adcSourceTileTopExtFlag = true;
        }

        if (ty0 + th + halfWindowHeight <= sourceImageHeight) {
            adcSourceTileBottomExtFlag = true;
        }

        if (adcSourceTileTopExtFlag) {
            sy0 = ty0 - halfWindowHeight;
            sh += halfWindowHeight;
        }

        if (adcSourceTileBottomExtFlag) {
            sh += halfWindowHeight;
        }

        return new Rectangle(sx0, sy0, sw, sh);
    }

    private RenderedImage getIntensityImage(
            Rectangle sourceTileRectangle, ProgressMonitor pm, String[] srcBandNames, Unit.UnitType bandUnit) {

        final int sx0 = sourceTileRectangle.x;
        final int sy0 = sourceTileRectangle.y;
        final int sw = sourceTileRectangle.width;
        final int sh = sourceTileRectangle.height;
        final double[] array = new double[sw*sh];

        Tile sourceRaster1 = null;
        Tile sourceRaster2 = null;
        if (srcBandNames.length == 1) {
            sourceRaster1 = getSourceTile(sourceBand1, sourceTileRectangle, pm);
        } else {
            sourceRaster1 = getSourceTile(sourceBand1, sourceTileRectangle, pm);
            sourceRaster2 = getSourceTile(sourceBand2, sourceTileRectangle, pm);
        }

        final ProductData srcData1 = sourceRaster1.getDataBuffer();
        ProductData srcData2 = null;
        if(sourceRaster2 != null)
            srcData2 = sourceRaster2.getDataBuffer();

        int index;
        double sigma, dn, i, q;
        int k = 0;
        final int maxY = sy0 + sh;
        final int maxX = sx0 + sw;
        for (int y = sy0; y < maxY; ++y) {
            for (int x = sx0; x < maxX; ++x) {

                index = sourceRaster1.getDataBufferIndex(x, y);

                if (bandUnit == Unit.UnitType.AMPLITUDE) {
                    dn = srcData1.getElemDoubleAt(index);
                    sigma = dn*dn;
                } else if (bandUnit == Unit.UnitType.INTENSITY) {
                    sigma = srcData1.getElemDoubleAt(index);
                } else { // COMPLEX
                    i = srcData1.getElemDoubleAt(index);
                    q = srcData2.getElemDoubleAt(index);
                    sigma = i * i + q * q;
                }

                array[k++] = sigma;
            }
        }
        return createRenderedImage(array, sw, sh);
    }

    private static RenderedImage createRenderedImage(double[] array, int width, int height) {

        // create rendered image with demension being width by height
        final SampleModel sampleModel = RasterFactory.createBandedSampleModel(DataBuffer.TYPE_DOUBLE, width, height, 1);
        final ColorModel colourModel = PlanarImage.createColorModel(sampleModel);
        final DataBufferDouble dataBuffer = new DataBufferDouble(array, array.length);
        final WritableRaster raster = RasterFactory.createWritableRaster(sampleModel, dataBuffer, new Point(0,0));
        return new BufferedImage(colourModel, raster, false, new Hashtable());
    }

    private RenderedImage downSampleImage(RenderedImage intendityImage) {

        final double scaleX = 1.0 / blockWidth; // 1/8 = 0.125
        final double scaleY = 1.0 / blockHeight; // 1/8 = 0.125
        return SubsampleAverageDescriptor.create(intendityImage, scaleX, scaleY, null);
    }

    private RenderedImage removeFactorsApplied(RenderedImage downSampledImage) {

        // Not complete for now
        final int w = downSampledImage.getWidth();
        final int h = downSampledImage.getHeight();
        final double[] array = new double[h*w];
        //final Raster data = downSampledImage.getData();
        final Raster data = downSampledImage.getData(new Rectangle(0,0,w,h));
        double sigma;
        int k = 0;
        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {

                sigma = data.getSampleDouble(x, y, 0);

                if (antennaPatternCorrectionFlag) {
                    sigma *= antennaPatternGain[x*blockWidth];
                }

                if (rangeSpreadingLossCompFlag) {
                    sigma /= rangeSpreadingLoss[x*blockWidth];
                }

                array[k++] = Math.sqrt(sigma * replicaPulseVariationsCorrectionFactor);
            }
        }

        return createRenderedImage(array, w, h);
    }

    private RenderedImage smoothImage(RenderedImage rawImage) {

        final int slidingWindowWidth = windowWidth/blockWidth;
        final int slidingWindowHeight = windowHeight/blockHeight;

        final BorderExtender extender = BorderExtender.createInstance(BorderExtender.BORDER_REFLECT);
        final RenderingHints hints = new RenderingHints(JAI.KEY_BORDER_EXTENDER,extender);

        final ParameterBlock pb = new ParameterBlock();
        pb.addSource(rawImage);
        pb.add(slidingWindowWidth);
        pb.add(slidingWindowHeight);
        pb.add(slidingWindowWidth/2);
        pb.add(slidingWindowHeight/2);
        return JAI.create("boxfilter", pb, hints);
    }

    private RenderedImage getSquaredImage(RenderedImage smoothedImage) {

        final ParameterBlock pb1 = new ParameterBlock();
        pb1.addSource(smoothedImage);
        pb1.addSource(smoothedImage);
        final RenderedImage squaredImage = JAI.create("multiply", pb1);

        final double[] v = {calibrationConstant};
        final ParameterBlock pb2 = new ParameterBlock();
        pb2.addSource(squaredImage);
        pb2.add(v);
        return JAI.create("dividebyconst", pb2, null);
    }

    private void computeADCPowerLossValue(RenderedImage squaredImage) {

        final int del = (windowHeight / 2) / blockHeight;

        final int w = squaredImage.getWidth();
        int h = squaredImage.getHeight();

        if (adcSourceTileTopExtFlag) {
            h -= del;
        }

        if (adcSourceTileBottomExtFlag) {
            h -= del;
        }
        if(h <= 0)
            h = 1;

        adcPowerLoss = new double[h][w];

        Raster data = squaredImage.getData();

        double dn;
        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {

                if (adcSourceTileTopExtFlag) {
                    dn = data.getSampleDouble(x, y + del, 0);
                } else {
                    dn = data.getSampleDouble(x, y, 0);
                }

                if (isERS1Mission) {
                    adcPowerLoss[y][x] = getPowerLossValue(dn, appendixF1);
                } else {
                    adcPowerLoss[y][x] = getPowerLossValue(dn, appendixF2);
                }
            }
        }
        /*
        for (int x = 0; x < w; x++) {
            System.out.print(adcPowerLoss[25][x] + ",");
        }
        System.out.println();
        */
    }

    // This function is for debugging only.
    private static void outputRealImage(RenderedImage I, int startIdx, int endIdx) {

        final Raster data = I.getData();
        final double[] real = data.getSamples(0, 0, I.getWidth(), I.getHeight(), 0, (double[])null);

        for (int i = startIdx; i <= endIdx; i++) {
            System.out.print(real[i] + ",");
        }
        System.out.println();
    }

    /**
     * Compute ADC power loss value for given pixel value using LUT in Appendix F1 or F2.
     * @param dn The pixel value
     * @param array 2-D array holding ADC power loss value data given in Appendix F1 or F2
     * @return The ADC power loss value (in linear scale)
     */
    private static double getPowerLossValue(double dn, double[][] array) {

        final int numRows = array.length;
        final int numCols = array[0].length;
        if (numCols != 2) {
            throw new OperatorException("Incorrect array dimension");
        }

        double dnInDb;
        if (dn < underFlowFloat) {
            return -underFlowFloat;
        } else {
            dnInDb = 10.0 * Math.log10(dn);
        }

        int row1 = 0;
        int row2 = 0;
        if (dnInDb < array[0][0]) {
            row1 = 0;
            row2 = 1;
        } else if (dnInDb > array[numRows-1][0]) {
            row1 = numRows - 2;
            row2 = numRows - 1;
        } else {
            for (int i = 1; i < numRows; i++) {
                if (dnInDb < array[i][0]) {
                    row1 = i - 1;
                    row2 = i;
                    break;
                }
            }
        }

        final double intensityK1 = array[row1][0];
        final double intensityK2 = array[row2][0];
        final double loss1 = array[row1][1];
        final double loss2 = array[row2][1];
        final double lambda = (dnInDb - intensityK1) / (intensityK2 - intensityK1);
        double loss = (1 - lambda)*loss1 + lambda*loss2;
        loss = Math.pow(10.0, loss / 10.0); // dB to linear scale

        return loss;
    }

    // ================================== PGS ENVISAT ============================================================

    /**
     * Get the processing facility identifier.
     */
    private void getProcessingFacilityIDFromENVISAT() {

        MetadataElement mph = sourceProduct.getMetadataRoot().getElement("MPH");
        if (mph == null) {
            throw new OperatorException("MPH not found");
        }

        MetadataAttribute attr = mph.getAttribute("proc_center");
        if (attr == null) {
            throw new OperatorException("proc_center not found");
        }

        pafID = attr.getData().getElemString();
        /*
        if (!pafID.contains(ESRIN) && !pafID.contains(D_PAF) && !pafID.contains(I_PAF) && !pafID.contains(UK_PAF)) {
            throw new OperatorException("Invalid processing facility identifier: " + pafID);
        }
        */
        //System.out.println("Processing facility identifier is " + pafID);
    }

    /**
     * Get number of records in Main Processing Params data set.
     */
    private void getNumOfRecordsInMainProcParam() {

        MetadataElement dsd = sourceProduct.getMetadataRoot().getElement("DSD").getElement("DSD.3");
        if (dsd == null) {
            throw new OperatorException("DSD not found");
        }

        MetadataAttribute numRecordsAttr = dsd.getAttribute("num_records");
        if (numRecordsAttr == null) {
            throw new OperatorException("num_records not found");
        }
        numMPPRecords = numRecordsAttr.getData().getElemInt();
        if (numMPPRecords < 1) {
            throw new OperatorException("Invalid num_records.");
        }
        //System.out.println("The number of Main Processing Params records is " + numMPPRecords);
    }

    /**
     * Get calibration factors from Metadata for each band in the product.
     */
    private void getCalibrationConstantFromENVISAT() {

        MetadataElement ads;

        if (numMPPRecords == 1) {
            ads = sourceProduct.getMetadataRoot().getElement("MAIN_PROCESSING_PARAMS_ADS");
        } else {
            ads = sourceProduct.getMetadataRoot().getElement("MAIN_PROCESSING_PARAMS_ADS").
                    getElement("MAIN_PROCESSING_PARAMS_ADS.1");
        }

        if (ads == null) {
            throw new OperatorException("MAIN_PROCESSING_PARAMS_ADS not found");
        }

        MetadataAttribute calibrationFactorsAttr =
                ads.getAttribute("ASAR_Main_ADSR.sd/calibration_factors.1.ext_cal_fact");

        if (calibrationFactorsAttr == null) {
            throw new OperatorException("calibration_factors.1.ext_cal_fact not found");
        }

        calibrationConstant = (double) calibrationFactorsAttr.getData().getElemFloat();
        /*
        calibrationFactor[0] = (double) calibrationFactorsAttr.getData().getElemFloat();

        calibrationFactorsAttr = ads.getAttribute("ASAR_Main_ADSR.sd/calibration_factors.2.ext_cal_fact");

        if (calibrationFactorsAttr == null) {
            throw new OperatorException("calibration_factors.2.ext_cal_fact not found");
        }

        calibrationFactor[1] = (double) calibrationFactorsAttr.getData().getElemFloat();

        if (Double.compare(calibrationFactor[0], 0.0) == 0 && Double.compare(calibrationFactor[1], 0.0) == 0) {
            throw new OperatorException("Calibration factors in metadata are zero");
        }
        */
        //System.out.println("calibration factor for band 1 is " + calibrationFactor[0]);
        //System.out.println("calibration factor for band 2 is " + calibrationFactor[1]);
    }

    /**
     * Compute incidence angles (in radian), look angles (in radian) and range spreading loss
     * for pixels in a complete range line.
     */
    private void computeIncidenceAnglesLookAnglesRangeSpreadingLossForENVISAT() {
//   private void computeIncidenceAnglesLookAnglesRangeSpreadingLoss() {

        incidenceAngles = new double[sourceImageWidth];
        lookAngles = new double[sourceImageWidth];
        rangeSpreadingLoss = new double[sourceImageWidth];

        final TiePointGrid incidenceAngleTiePointGrid = OperatorUtils.getIncidenceAngle(sourceProduct);
        final TiePointGrid slantRangeTimeTiePointGrid = OperatorUtils.getSlantRangeTime(sourceProduct);

        final double rSat = getSatelliteToEarthCenterDistanceForENVISAT();
        /*
        double rSat;
        if (isCEOSFormat) {
            rSat = getSatelliteToEarthCenterDistanceForCEOS();
        } else {
            rSat = getSatelliteToEarthCenterDistanceForENVISAT();
        }
        */
        final int y = sourceImageHeight/2;
        for (int x = 0; x < sourceImageWidth; x++) {

            final double alpha = incidenceAngleTiePointGrid.getPixelFloat(x + 0.5f, y + 0.5f) * MathUtils.DTOR; // in radian
            final double time = slantRangeTimeTiePointGrid.getPixelFloat(x + 0.5f, y + 0.5f) / 1000000000.0; //convert ns to s
            final double r = time * halfLightSpeed; // in m
            final double theta = alpha - Math.asin(Math.sin(alpha) * r / rSat); // in radian

            incidenceAngles[x] = alpha;
            lookAngles[x] = theta;
            rangeSpreadingLoss[x] = Math.pow(r/referenceSlantRange, 3.0);
        }
        /*
        for (int i = 0; i < sourceImageWidth; i=i+20) {
            System.out.print(incidenceAngles[i] + ", ");
        }
        System.out.println();
        for (int i = 0; i < sourceImageWidth; i=i+20) {
            System.out.print(lookAngles[i] + ", ");
        }
        System.out.println();
        for (int i = 0; i < sourceImageWidth; i=i+20) {
            System.out.print(rangeSpreadingLoss[i] + ", ");
        }
        System.out.println();
        */
    }

    /**
     * Compute distance from satellite to the Earth center using satellite corrodinate in Metadata.
     * @return The distance.
     */
    private double getSatelliteToEarthCenterDistanceForENVISAT() {

        final MetadataElement mppAds = sourceProduct.getMetadataRoot().getElement("MAIN_PROCESSING_PARAMS_ADS");
        if (mppAds == null) {
            throw new OperatorException("MAIN_PROCESSING_PARAMS_ADS not found");
        }

        MetadataElement ads;
        if (numMPPRecords == 1) {
            ads = mppAds;
        } else {
            ads = mppAds.getElement("MAIN_PROCESSING_PARAMS_ADS." + 1);
        }

        final MetadataAttribute xPositionAttr = ads.getAttribute("ASAR_Main_ADSR.sd/orbit_state_vectors.3.x_pos_1");
        if (xPositionAttr == null) {
            throw new OperatorException("x_pos_1 not found");
        }
        final float x_pos = xPositionAttr.getData().getElemInt() / 100.0f; // divide 100 to convert unit from 10^-2 m to m
        //System.out.println("x position is " + x_pos);

        final MetadataAttribute yPositionAttr = ads.getAttribute("ASAR_Main_ADSR.sd/orbit_state_vectors.3.y_pos_1");
        if (yPositionAttr == null) {
            throw new OperatorException("y_pos_1 not found");
        }
        final float y_pos = yPositionAttr.getData().getElemInt() / 100.0f; // divide 100 to convert unit from 10^-2 m to m
        //System.out.println("y position is " + y_pos);

        final MetadataAttribute zPositionAttr = ads.getAttribute("ASAR_Main_ADSR.sd/orbit_state_vectors.3.z_pos_1");
        if (zPositionAttr == null) {
            throw new OperatorException("z_pos_1 not found");
        }
        final float z_pos = zPositionAttr.getData().getElemInt() / 100.0f; // divide 100 to convert unit from 10^-2 m to m
        //System.out.println("z position is " + z_pos);

        final double rSat = Math.sqrt(x_pos * x_pos + y_pos * y_pos + z_pos * z_pos); // in m
        if (Double.compare(rSat, 0.0) == 0) {
            throw new OperatorException("x, y and z positions in orbit_state_vectors are all zeros");
        }

        return rSat;
    }

    /**
     * Get the replica pulse power for PGS ENVISAT product.
     * @return The replica pulse power.
     */
    private double getReplicaPulsePowerForENVISAT() {
        // Field 9 in CHIRP_PARAMS_ADS
        final MetadataElement dsd = sourceProduct.getMetadataRoot().getElement("CHIRP_PARAMS_ADS");
        if (dsd == null) {
            throw new OperatorException("CHIRP_PARAMS_ADS not found");
        }

        final MetadataAttribute attr = dsd.getAttribute("chirp_power");
        if (attr == null) {
            throw new OperatorException("chirp_power not found");
        }

        double replicaPulsePower = attr.getData().getElemFloat(); // in dB
        replicaPulsePower = Math.pow(10.0, replicaPulsePower / 10.0); // convert to linear scale
        //System.out.println("Replica pulse power is " + replicaPulsePower);

        return replicaPulsePower;
    }

    private double getSatelliteToEarthCenterDistanceForCEOS() {
        // Field 99 - 101 in PRI Facility Related Data Record
        final MetadataElement facility = sourceProduct.getMetadataRoot().getElement("Leader").getElement("Facility Related");
        if (facility == null) {
            throw new OperatorException("Facility Related not found");
        }

        final MetadataAttribute xAttr = facility.getAttribute("Input state vector - Position vector X");
        if (xAttr == null) {
            throw new OperatorException("Input state vector - Position vector X");
        }

        final double x = xAttr.getData().getElemDouble();

        final MetadataAttribute yAttr = facility.getAttribute("Input state vector - Position vector Y");
        if (yAttr == null) {
            throw new OperatorException("Input state vector - Position vector Y");
        }

        final double y = yAttr.getData().getElemDouble();

        final MetadataAttribute zAttr = facility.getAttribute("Input state vector - Position vector Z");
        if (zAttr == null) {
            throw new OperatorException("Input state vector - Position vector Z");
        }

        final double z = zAttr.getData().getElemDouble();

        return Math.sqrt(x*x + y*y + z*z);
    }

    /**
     * Gets a {@link Tile} for a given band and rectangle.
     *
     * @param rasterDataNode the raster data node of a data product,
     *                       e.g. a {@link org.esa.beam.framework.datamodel.Band Band} or
     *                       {@link org.esa.beam.framework.datamodel.TiePointGrid TiePointGrid}.
     * @param rectangle      the raster rectangle in pixel coordinates
     * @param pm             The progress monitor passed into the
     *                       the computeTile method or the computeTileStack method.
     * @return a tile.
     * @throws OperatorException if the tile request cannot be processed
     */
    public static Tile getSourceTile(RasterDataNode rasterDataNode, Rectangle rectangle, ProgressMonitor pm) throws OperatorException {
        return OperatorContext.getSourceTile(rasterDataNode, rectangle, pm);
    }

    public double applyCalibration(
            final double v, final double slantRange, final double satelliteHeight, final double sceneToEarthCentre,
            final double localIncidenceAngle, final int bandPolar, final Unit.UnitType bandUnit, int[] subSwathIndex) {

        double sigma = 0.0;
        if (bandUnit == Unit.UnitType.AMPLITUDE) {
            sigma = v*v;
        } else if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
            sigma = v;
        } else if (bandUnit == Unit.UnitType.INTENSITY_DB) {
            sigma = Math.pow(10, v/10.0); // convert dB to linear scale
        } else {
            throw new OperatorException("Uknown band unit");
        }

        return sigma / calibrationConstant *
               Math.sin(Math.abs(localIncidenceAngle)*org.esa.beam.util.math.MathUtils.DTOR);
    }

    public double applyRetroCalibration(int x, int y, double v, int bandPolar, final Unit.UnitType bandUnit, int[] subSwathIndex) {
        return v;
    }
    
}
